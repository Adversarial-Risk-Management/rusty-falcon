/*
 * CrowdStrike API Specification
 *
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: rolling
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::de::Error as _;

/// struct for typed errors of method [`create_migration_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMigrationV1Error {
    Status400(models::ApiPeriodCreateMigrationResponseV1),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::ApiPeriodCreateMigrationResponseV1),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::ApiPeriodCreateMigrationResponseV1),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_host_migration_ids_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHostMigrationIdsV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_host_migrations_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHostMigrationsV1Error {
    Status400(models::ApiPeriodGetHostMigrationResponseV1),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::ApiPeriodGetHostMigrationResponseV1),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::ApiPeriodGetHostMigrationResponseV1),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_migration_destinations_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMigrationDestinationsV1Error {
    Status400(models::MsaspecPeriodResponseFields),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::MsaspecPeriodResponseFields),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodResponseFields),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_migration_ids_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMigrationIdsV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_migrations_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMigrationsV1Error {
    Status400(models::ApiPeriodGetMigrationsResponseV1),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::ApiPeriodGetMigrationsResponseV1),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::ApiPeriodGetMigrationsResponseV1),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`host_migration_aggregates_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HostMigrationAggregatesV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`host_migrations_actions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HostMigrationsActionsV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::MsaspecPeriodQueryResponse),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`migration_aggregates_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MigrationAggregatesV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`migrations_actions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MigrationsActionsV1Error {
    Status400(models::MsaspecPeriodQueryResponse),
    Status403(models::MsaPeriodReplyMetaOnly),
    Status404(models::MsaspecPeriodQueryResponse),
    Status429(models::MsaPeriodReplyMetaOnly),
    Status500(models::MsaspecPeriodQueryResponse),
    UnknownValue(serde_json::Value),
}

/// `device_ids` and `filter` are mutually exclusive. Filter takes precedence.
pub async fn create_migration_v1(
    configuration: &configuration::Configuration,
    body: models::ApiPeriodCreateMigrationRequestV1,
) -> Result<models::ApiPeriodCreateMigrationResponseV1, Error<CreateMigrationV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/entities/migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiPeriodCreateMigrationResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiPeriodCreateMigrationResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMigrationV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Query host migration IDs.
pub async fn get_host_migration_ids_v1(
    configuration: &configuration::Configuration,
    id: &str,
    offset: Option<i32>,
    limit: Option<i32>,
    sort: Option<&str>,
    filter: Option<&str>,
) -> Result<models::MsaspecPeriodQueryResponse, Error<GetHostMigrationIdsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_offset = offset;
    let p_limit = limit;
    let p_sort = sort;
    let p_filter = filter;

    let uri_str = format!(
        "{}/host-migration/queries/host-migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHostMigrationIdsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// # Events   The `events` field describes actions that have occurred to the host migration entity. Each object is defined by the `action` field. When `user` is present, it is the user who performed the action. `time` is when the action occurred.  ## Event actions  ### added  This action is emitted when the host migration is created.  ``` { \"action\": \"added\", \"user\": \"example@example.com\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### assigned_static_host_groups  This action is emitted when a user assigns static host groups to a host migration. `ids` are the ids of the new host groups that have been assigned.  ``` { \"action\": \"assigned_static_host_groups\", \"ids\": [\"foo\", \"bar\"],  \"user\": \"example@example.com\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### removed_static_host_groups  This action is emitted when a user removes static host groups from a host migration. `ids` are the ids of the host groups that have been removed.  ``` { \"action\": \"removed_static_host_groups\", \"ids\": [\"foo\", \"bar\"],  \"user\": \"example@example.com\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### queued  This action is emitted when the migration is started.  ``` { \"action\": \"queued\", \"user\": \"example@example.com\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### failed  This action is emitted when the host migration fails. `reason` is the reason for failure. `reason` can be `unsupported_sensor_version`, `unsupported_sensor_platform`, `host_missing`, `migration_expired`, or `internal_error`.  ``` { \"action\": \"failed\", \"reason\": \"unsupported_sensor_version\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### cancelled  This action is emitted when the migration has been cancelled.  ``` { \"action\": \"cancelled\", \"user\": \"example@example.com\", \"time\": \"2024-01-01T00:00:00Z\" } ```  ### completed  This action is emitted when the host has successfully migrated.  ``` { \"action\": \"completed\", \"time\": \"2024-01-01T00:00:00Z\" } ```  # Status Details  The `status_details` field is an optional field that provides some more details about the status of a failed host migration. It may be omitted or empty from a response.  ### internal_error  This status detail is provided when an internal occurs during a host migration.  ### canceled_by_user  This status detail is provided when a migration has been canceled by a user.  ### host_missing  This status detail is provided when a host migration is canceled because the source host can no longer be found.  ### migration_expired  This status detail is provided when a host migration is expired because the migration is too old.  ### migration_already_in_progress  This status detail is provided when attempting to start a host migration on a host that is already in progress in another migration.  ### source_host_unsupported_version  This status detail is provided when attempting to create or start a host migration when the sensor is on an unsupported version.  ### source_host_unsupported_platform  This status detail is provided when attempting to create or start a host migration when the sensor is an unsupported platform.
pub async fn get_host_migrations_v1(
    configuration: &configuration::Configuration,
    body: models::MsaPeriodIdsRequest,
) -> Result<models::ApiPeriodGetHostMigrationResponseV1, Error<GetHostMigrationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/entities/host-migrations/GET/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiPeriodGetHostMigrationResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiPeriodGetHostMigrationResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHostMigrationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// `device_ids` and `filter` are mutually exclusive.
pub async fn get_migration_destinations_v1(
    configuration: &configuration::Configuration,
    body: models::ApiPeriodGetMigrationDestinationsRequestBodyV1,
) -> Result<
    models::ApiPeriodGetMigrationDestinationsResponseV1,
    Error<GetMigrationDestinationsV1Error>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/entities/migration-destinations/GET/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiPeriodGetMigrationDestinationsResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiPeriodGetMigrationDestinationsResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMigrationDestinationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_migration_ids_v1(
    configuration: &configuration::Configuration,
    offset: Option<i32>,
    limit: Option<i32>,
    sort: Option<&str>,
    filter: Option<&str>,
) -> Result<models::MsaspecPeriodQueryResponse, Error<GetMigrationIdsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_offset = offset;
    let p_limit = limit;
    let p_sort = sort;
    let p_filter = filter;

    let uri_str = format!(
        "{}/host-migration/queries/migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMigrationIdsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn get_migrations_v1(
    configuration: &configuration::Configuration,
    ids: Vec<String>,
) -> Result<models::ApiPeriodGetMigrationsResponseV1, Error<GetMigrationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;

    let uri_str = format!(
        "{}/host-migration/entities/migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(
            &p_ids
                .into_iter()
                .map(|p| ("ids".to_owned(), p.to_string()))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => req_builder.query(&[(
            "ids",
            &p_ids
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiPeriodGetMigrationsResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiPeriodGetMigrationsResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMigrationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get host migration aggregates as specified via json in request body.  # Supported Types  Both types support the following FQL filter properties: `groups`, `hostgroups`, `static_host_groups`, `hostname`, `status`, `target_cid`, `source_cid`, `migration_id`, `id`, `host_migration_id`, `created_time`.  The values `groups` and `hostgroups` are aliases for `static_host_groups`.  The value `host_migration_id` is an alias for `id`  ## Terms `\"type\": \"terms\"`  Supported `field` values: `groups`, `hostgroups`, `static_host_groups`, `hostname`, `status`, `target_cid`, `source_cid`, `migration_id`, `id`, `host_migration_id`.  `sort` must be done on the same value as `field` and include a direction (`asc` or `desc`). Supports all FQL fields except for `groups`, `hostgroups`, or `static_host_groups`.  Examples sort value: `status|asc` or `created_by|desc`   ## Date Range `\"type\": \"date_range\"`  Supported `field` fields: `created_time`.  Does not support `sort`, `size`, or `from`.
pub async fn host_migration_aggregates_v1(
    configuration: &configuration::Configuration,
    body: Vec<models::MsaPeriodAggregateQueryRequest>,
) -> Result<models::MsaPeriodAggregatesResponse, Error<HostMigrationAggregatesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/aggregates/host-migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaPeriodAggregatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaPeriodAggregatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HostMigrationAggregatesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// The available actions are `add_host_groups`, `remove_host_groups`, and `remove_hosts`.  FQL filter supports the following fields: `groups`, `hostgroups`, `static_host_groups`, `hostname`, `status`, `target_cid`, `source_cid`, `migration_id`, `id`, `host_migration_id`, `created_time`.  These actions only works if the migration has not started.  `add_host_groups` adds static host groups to the selected hosts in a migration. This action accepts the following action parameter: `{ \"name\": \"host_group\": \"value\": \"$host_group_id\" }`. Action parameters can be repeated to add multiple static host groups in a single request.  `remove_host_groups` removes static host groups from the selected hosts in a migration. This action accepts the following action parameter: `{ \"name\": \"host_group\": \"value\": \"$host_group_id\" }`. Action parameters can be repeated to remove multiple static host groups in a single request.  `remove_hosts` removes the selected hosts from a migration. This action does not accept any action parameters.
pub async fn host_migrations_actions_v1(
    configuration: &configuration::Configuration,
    id: &str,
    action_name: &str,
    body: models::MsaPeriodEntityActionRequestV3,
) -> Result<models::MsaspecPeriodQueryResponse, Error<HostMigrationsActionsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_action_name = action_name;
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/entities/host-migrations-actions/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("id", &p_id.to_string())]);
    req_builder = req_builder.query(&[("action_name", &p_action_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HostMigrationsActionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get migration aggregates as specified via json in request body.  # Supported Types  Both types support the following FQL filter props: `name`, `id`, `migration_id`, `target_cid`, `status`, `migration_status`, `created_by`, `created_time`.  The value `migration_status` is an alias for `status`.  The value `migration_id` is an alias for `id`.  ## Terms `\"type\": \"terms\"`  Supported `field` values: `name`, `id`, `migration_id,` `target_cid`, `status`, `migration_status`, `created_by`.  `sort` on `terms` type must be done on the same value as `field` and include a direction (`asc` or `desc`). Supports all supported FQL fields.  Examples sort value: `status|asc` or `created_by|desc`.   ## Date Range `\"type\": \"date_range\"`  Supported `field` fields: `created_time`.  Does not support `sort`, `size`, or `from`.  
pub async fn migration_aggregates_v1(
    configuration: &configuration::Configuration,
    body: Vec<models::MsaPeriodAggregateQueryRequest>,
) -> Result<models::MsaPeriodAggregatesResponse, Error<MigrationAggregatesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/aggregates/migrations/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaPeriodAggregatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaPeriodAggregatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MigrationAggregatesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// The available actions are `start_migration`, `cancel_migration`, `rename_migration`, and `delete_migration`.  `start_migration` starts the selected migrations. This action only works if the migration has not started. This action does not accept any action parameters. Only one migration may be started per request.  `cancel_migration` cancels the selected migrations. This actions only works if the migration has started and not completed. This action does not accept any action parameters.  `rename_migration` renames the selected migrations. This action can be called at any time. Only 1 action parameter may be supplied. Action parameters take the form of `{\"name\": \"migration_name\": \"value\": \"$new_migration_name\"}`.  `delete_migration` deletes the selected migrations. This action only works if the migration has not started. This action does not accept any action parameters.
pub async fn migrations_actions_v1(
    configuration: &configuration::Configuration,
    action_name: &str,
    body: models::MsaPeriodEntityActionRequestV3,
) -> Result<models::MsaspecPeriodQueryResponse, Error<MigrationsActionsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_action_name = action_name;
    let p_body = body;

    let uri_str = format!(
        "{}/host-migration/entities/migrations-actions/v1",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("action_name", &p_action_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MsaspecPeriodQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MigrationsActionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
